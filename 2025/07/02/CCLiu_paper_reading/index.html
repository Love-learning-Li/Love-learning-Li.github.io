<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CCLiu 论文研读 | LiMingXiang's Record</title><meta name="author"><meta name="copyright"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="CCLiu 论文研读SAR ADC 技术点迭代 Non-binary传统二进制搜索算法的 CDAC 的 settling time 与分辨率成正比，很难将速度提上去。 请教一个关于 SARADC 的非二进制电容阵列的问题 - eetop 电容的 mismatch 带来错误的 charge redistribution 后的电压；transistor pair 的 mismatch 带来比较器的 o">
<meta property="og:type" content="article">
<meta property="og:title" content="CCLiu 论文研读">
<meta property="og:url" content="http://love-learning-li.github.io/2025/07/02/CCLiu_paper_reading/index.html">
<meta property="og:site_name" content="LiMingXiang&#39;s Record">
<meta property="og:description" content="CCLiu 论文研读SAR ADC 技术点迭代 Non-binary传统二进制搜索算法的 CDAC 的 settling time 与分辨率成正比，很难将速度提上去。 请教一个关于 SARADC 的非二进制电容阵列的问题 - eetop 电容的 mismatch 带来错误的 charge redistribution 后的电压；transistor pair 的 mismatch 带来比较器的 o">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://love-learning-li.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-07-02T07:31:41.985Z">
<meta property="article:modified_time" content="2025-07-02T07:32:48.280Z">
<meta property="article:tag" content="SAR ADC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://love-learning-li.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CCLiu 论文研读",
  "url": "http://love-learning-li.github.io/2025/07/02/CCLiu_paper_reading/",
  "image": "http://love-learning-li.github.io/img/butterfly-icon.png",
  "datePublished": "2025-07-02T07:31:41.985Z",
  "dateModified": "2025-07-02T07:32:48.280Z",
  "author": [
    {
      "@type": "Person",
      "name": null,
      "url": "http://love-learning-li.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://love-learning-li.github.io/2025/07/02/CCLiu_paper_reading/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CCLiu 论文研读',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">LiMingXiang's Record</span></a><a class="nav-page-title" href="/"><span class="site-name">CCLiu 论文研读</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">CCLiu 论文研读</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-02T07:31:41.985Z" title="发表于 2025-07-02 15:31:41">2025-07-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-02T07:32:48.280Z" title="更新于 2025-07-02 15:32:48">2025-07-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="CCLiu-论文研读"><a href="#CCLiu-论文研读" class="headerlink" title="CCLiu 论文研读"></a>CCLiu 论文研读</h1><p>SAR ADC 技术点迭代</p>
<h3 id="Non-binary"><a href="#Non-binary" class="headerlink" title="Non-binary"></a>Non-binary</h3><p>传统二进制搜索算法的 CDAC 的 settling time 与分辨率成正比，很难将速度提上去。</p>
<p><a target="_blank" rel="noopener" href="https://bbs.eetop.cn/thread-594016-1-1.html">请教一个关于 SARADC 的非二进制电容阵列的问题 - eetop</a></p>
<p>电容的 mismatch 带来错误的 charge redistribution 后的电压；transistor pair 的 mismatch 带来比较器的 offset，带来错误的比较结果。常用如下静态参数来衡量 ADC：微分非线性(Differential nonlinearity , DNL)、积分非线性(Integral nonlinearity , INL)、offset error、gain error。</p>
<p>‍</p>
<ul>
<li>DNL</li>
</ul>
<p>对于理想 ADC，其输出码没变化一次，输入信号理想应增加 1LSB，但实际可能不是 1LSB，这就是微分非线性：</p>
<script type="math/tex; mode=display">
\begin{aligned}
DNL(i) = \frac{V_{in}(i+1) - V_{in}(i) }{V_{LSB}} - 1
\end{aligned}</script><p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/image-20250511151435-u1n0cw3.png" alt="image" title="DNL示意图">​</p>
<ul>
<li>INL</li>
</ul>
<p>积分非线性（INL）是表征编码转换与其理想值的偏差的规范，为 DNL 的累加和。</p>
<script type="math/tex; mode=display">
INL(m) = \sum_{i=0}^{m-1}DNL(i)</script><ul>
<li>offset error and gain error</li>
</ul>
<p>offset error 是当 ADC 输入 $\frac{LSB}{2}$ 时，输出是否发生从 0-1 的跳变。</p>
<p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/20250515170619.png" alt="image" title="offset error示意图">​</p>
<p>gain error 有很多校准方法，最简单的方法是两点校准，测得输出”000”和”111”的两点然后连线。</p>
<p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/image-20250511153926-cbmeup1.png" alt="image" title="gain error示意图">​</p>
<p>对于 3Bits ADC 时 gain error 即为输出”111”的输入模拟电压与 7LSB 之间的差值。</p>
<p>‍</p>
<h4 id="Non-binary-search-详细分析"><a href="#Non-binary-search-详细分析" class="headerlink" title="Non-binary search 详细分析"></a>Non-binary search 详细分析</h4><p>​<code>传统的二进制搜索算法不能容忍任何判断误差</code>​，因为没有冗余位，如果 MSB 判断错误，后面所有的 Bit 加起来都矫正不过来。但是 sub-binary is less efficient。例如传统 4Bit Binary ADC 的权重是[8,4,2,1]，sub-binary 的权重可以设定为[8,2,2,1,1,1]，故 sub-binary 需要 6 次比较才能实现 same resolution。对于 N-bit，M-step 的 ADC，其数字输出满足下式：</p>
<script type="math/tex; mode=display">
D_{out} = s(M) + \sum_{i=1}^{M-1} [ 2\cdot b[i] - 1 ] \times s(i) + [ b[0] - 1 ]</script><p>注意第 M 位是最高位，即其权重为 8；第 0 位是最低位，其权重位 1。其中 $b[i]$ 是第 i 位的输出结果，$(2\cdot b[i] - 1)$ 是将 0/1 的输出转化成-1、+1 进而来求和。由于第一位永远猜是 1，即 $b(M) = 1$，这也是为什么 $s(M)$ 单独在求和外面。其中 $(b[0]-1)$ 不同于其他 bit 的求和方式是因为<strong>它的主要作用是用来微调输出结果，故采用这种简单的计算方式。</strong></p>
<p>因此我们可以得到若输出结果 $D_{out}$ 等于 6，则其对应多种输出的 code：</p>
<p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/image-20250515151351-ldsjywj.png" alt="image" title="Non-binary search: (a) Correct conversion. (b) Conversion with wrong decision.">​</p>
<p>因此它可以接收某个 bit 出现判断错误即 error output，鲁棒性更好。<strong>但是它的 tolerance 并不是无限的</strong>，因此我们定义 error tolerance window $\epsilon_{t}$，其描述的是 the range of recoverable analog voltage，如果目前的 error voltage 总和未超过 $\epsilon_{t}$，那么在该权重的引导下，它能恢复至正确的输出值。</p>
<ul>
<li>error tolerance window $\epsilon_{t}$</li>
</ul>
<p>对于 n bit 的输出，其 error tolerance window 满足下式：</p>
<script type="math/tex; mode=display">
\epsilon_{t} (n) = \sum_{i=1}^{n-2} s(i) - s(n-1)</script><p>以 5bit 的[8,2,2,2,1]的权重为例，其 error tolerance window=1+2+2-2=3，因此 the range of recoverable analog voltage = $[8-3,8+3] = [5,11]$。</p>
<p>‍</p>
<h3 id="Time-interleaving"><a href="#Time-interleaving" class="headerlink" title="Time-interleaving"></a>Time-interleaving</h3><p>来自《Design Considerations for Interleaved ADCs》——Razavi</p>
<p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/image-20250511200643-px3vobw.png" alt="image" title="Time-interleaving ADC示意图">​</p>
<h4 id="5-11-20-43-暂时看不懂，暂且先搁置"><a href="#5-11-20-43-暂时看不懂，暂且先搁置" class="headerlink" title="5.11 20:43 暂时看不懂，暂且先搁置"></a>5.11 20:43 暂时看不懂，暂且先搁置</h4><p>‍</p>
<p>参考资料 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44537056/article/details/112790141">Time-Interleaved Analog-to-Digital Converters-CSDN 博客</a>，拉扎维先生的 JSSC</p>
<p>‍</p>
<h3 id="Asynchronous"><a href="#Asynchronous" class="headerlink" title="Asynchronous"></a>Asynchronous</h3><p>对于 N bit 的 SAR ADC 需要至少 N+1 个周期完成转换(1 个采样 +N 个比较)，但对于动态 latch 比较器而言，较小的 Vin 对于较小的 X、OUT 结点的电容放电电流，进而 $V_{out+}$ 和 $V_{out-}$ 两节点之间的差距很难被迅速放大然后进入耦合反相器的正反馈中。即小信号比较时间较长，大信号比较时间较短。<strong>同步逻辑</strong>指的是选用最差的时间做为比较周期，但这无疑会降低 ADC 工作频率，很自然的一个想法就是当前 bit 比较完后输出一个 valid 信号，然后下一个 bit 立刻开始比较不等待，可以提升工作频率。</p>
<p>同时异步逻辑不需要 PLL 电路，有专门的逻辑信号产生电路。</p>
<p>‍</p>
<h3 id="Reduce-the-switching-energy-in-CDAC"><a href="#Reduce-the-switching-energy-in-CDAC" class="headerlink" title="Reduce the switching energy in CDAC"></a>Reduce the switching energy in CDAC</h3><p>比较器和 CDAC 的功耗受 mismatch 和 noise 的限制，因此存在如下减小 CDAC 功耗的方法：split capacitor；energy-saving method；单调开关 monotonic switching 切换策略；</p>
<p>但是单调开关切换策略依赖于输入共模电平的 offset 会 degrade ADC 的线性度，因此提出 splitting monotonic switching 切换策略，使得 signal-dependent offset 不影响 ADC 线性度。</p>
<p>类似于 non-binary 方法，binary-scaled error compensation method 被提出克服 CDAC 的 settling issue，同时相较于 non-binary 方法，其需要更少的硬件和设计。</p>
<p>CCLiu 提出一种 predictive circuit 来避免 CDAC 中不必要的能量消耗，在不影响运行速度的情况下减小功耗同时提高线性度。</p>
<p>‍</p>
<h3 id="Chapter2-开关的单调切换策略"><a href="#Chapter2-开关的单调切换策略" class="headerlink" title="Chapter2 开关的单调切换策略"></a>Chapter2 开关的单调切换策略</h3><p>在 charge-redistribution 结构中，capacitor 网络同时担任 S/H 网络和 CDAC 阵列的作用。</p>
<p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/image-20250511212959-1j6h88q.png" alt="image" title="Conventional and Proposed CDAC阵列结构对比">​</p>
<h4 id="Conventional-CDAC"><a href="#Conventional-CDAC" class="headerlink" title="Conventional CDAC"></a>Conventional CDAC</h4><p>以上半部分电容阵列为例：采样阶段，电容下极板充电至 $V_{ip}$，上极板被置位到 $V_{cm}$，然后 MSB 位对应的最大的电容 $C_{1}$ 上极板由 $V_{ip}$ 切换到 $V_{ref}$，同时其他电容接地。具体分析参考下方链接：</p>
<p><a target="_blank" rel="noopener" href="https://bbs.eetop.cn/thread-987317-1-1.html">CCLiu adc 论文中开关电容切换时的能量消耗的详细计算 - EETOP</a></p>
<p>‍</p>
<p>‍</p>
<h4 id="Proposed-CDAC"><a href="#Proposed-CDAC" class="headerlink" title="Proposed CDAC"></a>Proposed CDAC</h4><p>上极板采样 → 提高速度又拓展带宽；下极板最开始统一置位到 $V_{ref}$；当 ADC 关闭自举开关(即结束采样后)，比较器直接开始工作，不需要像传统结构那样将上极板由 $V_{ip}$ 切换到 $V_{ref}$ 然后再开始比较：</p>
<p>‍</p>
<p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/image-20250513111302-w1uzhvo.png" alt="image" title="3Bits为例的Proposed 单调开关切换策略">​</p>
<p>‍</p>
<script type="math/tex; mode=display">
\begin{aligned}
Q_{p}(0) &= 4C\cdot (V_{ip}-V_{ref})\\
Q_{n}(0) &= 4C\cdot (V_{in}-V_{ref})\\
\end{aligned}</script><p>采样结束后直接开始比较：</p>
<script type="math/tex; mode=display">
\begin{aligned}
V_{p}(1) &= V_{ip}\\
V_{n}(1) &= V_{in}\\
\end{aligned}</script><p>第二步比较过程：</p>
<script type="math/tex; mode=display">
\begin{aligned}
Q_{p}(1) &= 2C\cdot (V_{p}(1)-V_{ref}) + 2C\cdot (V_{p}(1)-0)\\
Q_{n}(1) &= 4C\cdot (V_{in}-V_{ref})\\
\end{aligned}</script><p>根据电荷守恒求解 $V_{p}(2,up)$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
V_{p}(2,up) &= V_{ip} - \frac{1}{2}V_{ref}\\
V_{n}(2,up) &= V_{in}\\
\end{aligned}</script><p>进而实现 $V_{ip} - V_{in} &gt;? \frac{1}{2}V_{ref}$ 的比较。</p>
<script type="math/tex; mode=display">
\begin{aligned}
V_{comp,p} &= (C_{1} + ... +C_{9})\cdot (V_{ip}-V_{ref})+C_{10}\cdot V_{ip}\\
       &=  \\
V_{comp,n} &= (C_{1} + ... +C_{9})\cdot (V_{in}-V_{ref})+C_{10}\cdot V_{in}\\
\end{aligned}</script><p>过程消耗能量的比较：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E_{avg,conv} &= \sum_{i=1}^{n} 2^{n+1-2i}(2^{i}-1)CV_{ref}^{2}\\
E_{avg,mono} &= \sum_{i=1}^{n-1} (2^{n-2-i})CV_{ref}^{2}
\end{aligned}</script><p>由于 ADC 输出每个 code 的概率一致，因此我们需要对输出所有 code 的能量总和取平均。若以 10-bit 为例，则代入得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E_{avg,conv} &= \sum_{i=1}^{10} 2^{11-2i}(2^{i}-1)CV_{ref}^{2}\\
             &= \sum_{i=1}^{10}（2^{11-i}-2^{11-2i})CV_{ref}^{2} \\
             &= [2^{11} \cdot (1-\frac{1}{2^{10}}) - 2^{11} \cdot \frac{1}{3} ]CV_{ref}^{2} \\
             &= 1363.3CV_{ref}^{2} \\
E_{avg,mono} &= \sum_{i=1}^{9} (2^{8-i})CV_{ref}^{2}\\
             &= 2^{8} \cdot (1-\frac{1}{2^{9}})CV_{ref}^{2}\\
             &= 255.5CV_{ref}^{2}
\end{aligned}</script><p>其中 $E_{avg,conv}$ 在原文中给出的是 $1365.3CV_{ref}^{2}$，推测可能是忽略了 $\frac{1}{2^{10}}$，不过并不影响两种切换策略的能量消耗之间存在数量级的差异。也有人指出这是类 <code>Vcm-based</code> ​切换策略。</p>
<p>‍</p>
<h3 id="Bootstrapped-switch-design"><a href="#Bootstrapped-switch-design" class="headerlink" title="Bootstrapped switch design"></a>Bootstrapped switch design</h3><p>参考之前写的自举开关报告</p>
<p>‍</p>
<p>‍</p>
<h3 id="Comparator-design"><a href="#Comparator-design" class="headerlink" title="Comparator design"></a>Comparator design</h3><p>proposed latch-based dynamic comparator，结构如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/image-20250513164052-t820qwb.png" alt="image" title="latch-based dynamic comparator">​</p>
<p>就是 strong-arm latch+ 输出结点的反相器。</p>
<p>不过不同于它是 nmos 输入，但是 pmos 的 1/f 噪声更小，<code>不知道为什么这样选？</code>​</p>
<h3 id="SAR-ADC-control-logic"><a href="#SAR-ADC-control-logic" class="headerlink" title="SAR ADC control logic"></a>SAR ADC control logic</h3><p>‍</p>
<p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/image-20250514151214-jkjz0op.png" alt="image" title="内部时钟产生模块的Schematic and Timing diagram">​</p>
<p>D Flip-flop 当 CLK_in 上升沿到来时，输出 Q=D；</p>
<h4 id="diagram-分析"><a href="#diagram-分析" class="headerlink" title="diagram 分析"></a>diagram 分析</h4><p>注意前 10 个 D Flip-Flop 具有一个低电平使能端；</p>
<p>❌：因此当前 10 个 D Flip-Flop 的使能端输入低电平时，其输出 <code>复位</code>​，输出 0；但 CLK(9)初值为高，则 CLK10 输出高，进而我们将 CLK(10)做为前 10 个 D Flip-Flop 的使能信号控制信号；下一个时刻 CLK(10)读入 CLK9 复位后输出的低电平，进而前 10 个 D Flip-Flop 脱离复位状态，进入正常工作状态。</p>
<p>✔：当前 10 个 D Flip-Flop 的使能端输入低电平时，其 <code>正常工作</code>​，即上升沿到来时 Q(n+1)=D(n)；CLKs=$\overline{CLK(0)}$</p>
<ul>
<li>CLK_in-1：先采样：    CLK_in 第一个上升沿到来时，DFF(1)-DFF(10)被置位输出低电平，因此 CLKs=$\overline{Q(1)}=1$；CLK(1)-CLK(9)输出低电平，CLK(10)输出高电平；</li>
<li>CLK_in-2：CLK(0)读入 $\overline{CLK(10)}=0$，故此时 CLK(0)-CLK(10)均输出逻辑 0；故 CLKs=$\overline{Q(1)}=1$；CLKc = CLKs $\cup$ CLKin=1；</li>
<li>CLK_in-3：CLK(0)读入 $\overline{CLK(10)}=1$，故此时 CLKs=0，故 CLKc=CLK_in，因此 CLKc 在这个周期内一半时间高电平、一半时间低电平；且 CLK(1)-CLK(10)均为逻辑 0</li>
<li>CLK_in-4：CLK(0)读入 $\overline{CLK(10)}=1$，CLK(1)读入 CLK(0)=1；同时 CLK(2)-CLK(10)均为逻辑 0；CLKc=CLK_in，故一半时间高电平、一半时间低电平；</li>
<li>后面的周期类似，逐 bit 读入逻辑 1；</li>
</ul>
<p>‍</p>
<h3 id="Capacitor-Array"><a href="#Capacitor-Array" class="headerlink" title="Capacitor Array"></a>Capacitor Array</h3><p>10Bits ADC 共需 $2^{9}$ 个 unit capacitor；</p>
<p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/image-20250514170917-uel4l86.png" alt="image" title="电容阵列Layout排布图示">​</p>
<h3 id="10-bit-50MS-s-SAR-ADC-design"><a href="#10-bit-50MS-s-SAR-ADC-design" class="headerlink" title="10-bit 50MS/s SAR ADC design"></a>10-bit 50MS/s SAR ADC design</h3><h4 id="S-H-circuit"><a href="#S-H-circuit" class="headerlink" title="S/H circuit"></a>S/H circuit</h4><p>由于 $C_{ds}$ 的存在(典型值 5fF)，输入信号会耦合至采样电容上，耦合作用恶化了自举开关的高频性能，因为 $C_{ds}$ 在 comp 阶段中会带来 unequal 的电荷注入，这会带来一个 dynamic offset。因此采用一个交叉耦合的 mom 电容来减小该作用的影响至 $&lt;\frac{1}{2}LSB$，若想实现更高的准确度，dummy switchs 和 dummy routing 也是一种方法来抑制作用。</p>
<p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/image-20250514172142-9nqpzfg.png" alt="image" title="Cross-coupled capacitors">​</p>
<p>​<code>感觉就是互补开关管的思想</code>​</p>
<p>‍</p>
<h3 id="Dynamic-Comparator"><a href="#Dynamic-Comparator" class="headerlink" title="Dynamic Comparator"></a>Dynamic Comparator</h3><p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/image-20250514172314-h8e5d61.png" alt="image" title="Dynamic Comparator">​</p>
<p>感觉就是 strong-arm 结构的比较器，只不过它是 pmos 输入，<code>可能是为了减小1/f噪声？</code>​，然后输出端加了一个反相器以保证正确的输出比较结果，<code>但是我加了三个比较器，希望增强驱动能力？</code>​</p>
<p>同时作者提出该结构的 offset voltage 满足下式：</p>
<script type="math/tex; mode=display">
V_{os} = \Delta V_{TH1,2} + \frac{(V_{GS}-V_{TH})_{1,2}}{2} (\frac{\Delta S_{1,2}}{S_{1,2}} + \frac{\Delta R}{R} )</script><p>其中 $S=W\cdot L$；R 是负载电阻；其中第一项 $\Delta V_{TH1,2}$ 是 static offset，并不影响 SAR ADC 的 performance；第二项是依赖于 signal 的 dynamic offset。</p>
<p>并且通过添加 $Valid = \overline{Out_{n}\cap Out_{p}}$，即如果有逻辑 0 则输出 1，进而便于后续实现异步逻辑。</p>
<p>‍</p>
<h5 id="减小-offset-的方法："><a href="#减小-offset-的方法：" class="headerlink" title="减小 offset 的方法："></a>减小 offset 的方法：</h5><ul>
<li>提升 comparator 尺寸，但会增大功耗；</li>
<li>减小输入管的 effective voltage(感觉是过驱动电压)，但会降低速度；</li>
<li>采用 error tolerant non-binary search 算法；</li>
<li>​<code>增加Mb以形成cascode结构</code>​，保障稳定的漏极电流；</li>
</ul>
<p>‍</p>
<h3 id="6-bit-220-MS-s-Time-Interleaving-SAR-ADC"><a href="#6-bit-220-MS-s-Time-Interleaving-SAR-ADC" class="headerlink" title="6-bit 220-MS/s Time-Interleaving SAR ADC"></a>6-bit 220-MS/s Time-Interleaving SAR ADC</h3><p>应用场景：硬盘驱动、本地网络需要高速 ADC，但是精度 6-bit 足够；因此考虑 <code>异步逻辑+时间交织</code>​；</p>
<ul>
<li>由于 SAR ADC 常过采样，因此高频工作的 SAR 需要 2 倍频率的时钟，提出时间交织技术即为了避免使用高频时钟；</li>
</ul>
<p>但并行转换器数量的增加会带来功耗和面积的增加。</p>
<p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/image-20250514202306-fzctx84.png" alt="image" title="Time-Interleaving SAR结构图">​</p>
<p>‍</p>
<h4 id="Comparator-design-1"><a href="#Comparator-design-1" class="headerlink" title="Comparator design"></a>Comparator design</h4><p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/image-20250514205307-jvu7bff.png" alt="image" title="高速比较器结构图">​</p>
<p>为减小两个 sub-ADC 的 channel mismatch，调整比较器的 offset 满足 $&lt;\frac{1}{6}LSB$，同时要注意 layout <code>共质心布局</code>​，且无 dc 电流和静态功耗。</p>
<p>‍</p>
<h5 id="Q-不同于上一个-ADC-的-comparator-的原因？"><a href="#Q-不同于上一个-ADC-的-comparator-的原因？" class="headerlink" title="Q:不同于上一个 ADC 的 comparator 的原因？"></a>Q:不同于上一个 ADC 的 comparator 的原因？</h5><p>A:上一个 ADC 是 10-bit，它对 offset 的要求更高，这个 adc 只需要 $&lt;\frac{1}{6}LSB$ 即可，因此不需要添加 Mb 构成 cascode 结构稳定漏极电流。</p>
<p>‍</p>
<h4 id="SAR-Logic-Design"><a href="#SAR-Logic-Design" class="headerlink" title="SAR Logic Design"></a>SAR Logic Design</h4><p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/image-20250514211533-6p290kt.png" alt="image" title="The SAR logic implementation">​</p>
<p>仍然为单调开关切换策略，利用 Valid 信号的上升沿做为 DFF 的 CLK；</p>
<p>‍</p>
<h2 id="高速-SAR-ADC-的-Binary-Scaled-Error-Compensation"><a href="#高速-SAR-ADC-的-Binary-Scaled-Error-Compensation" class="headerlink" title="高速 SAR ADC 的 Binary-Scaled Error Compensation"></a>高速 SAR ADC 的 Binary-Scaled Error Compensation</h2><h4 id="传统的-Binary-Search："><a href="#传统的-Binary-Search：" class="headerlink" title="传统的 Binary Search："></a>传统的 Binary Search：</h4><p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/image-20250514213036-nzo1olk.png" alt="image" title=" (a) Correct conversion (b) Wrong conversion">​</p>
<p>传统的二进制搜索算法 <code>一旦出现错误判断的bit</code>​，即使后续所有的 bit 全部翻转也无法纠正。导致比较器判断错误的原因很多：comparator 的 metastability issue；thermal noise；supply voltage noise；采样频率过高导致 DAC 阵列来不及 stabilize；</p>
<p>‍</p>
<h4 id="Non-binary-Search"><a href="#Non-binary-Search" class="headerlink" title="Non-binary Search"></a>Non-binary Search</h4><p>参考下方跳转内容：</p>
<p>Non-binary search 详细分析</p>
<p>‍</p>
<h4 id="Proposed-Binary-Search-with-Error-Compensation"><a href="#Proposed-Binary-Search-with-Error-Compensation" class="headerlink" title="Proposed Binary Search with Error Compensation"></a>Proposed Binary Search with Error Compensation</h4><p>判断过程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/image-20250515154359-lb86xba.png" alt="image" title="Left Fig :Binary search with error compensation: (a) Correct conversion (b) Conversion with wrong decision.
Right Fig :DAC settling: (a) Binary search. (b) Binary search with error compensation.">​</p>
<p>如 Right Fig 所示，当 $B_{1}$ 判断结束后，$V_{ref}$ 切换后 $C_{comp,+}$ 和 $V_{comp,-}$ 没能在 $B_{2}$ 开始判断前 stabilize，进而导致判断错误。</p>
<p>增加了一个补偿 bit 来纠正错误的输出 code，补偿的 bit 权重=LSB；对于补偿 bit 常规的 0/1 求和输出是有问题的，它永远是非负的，因此不能纠正另一个极性的错误，因此我们采用 $2\cdot (B_{3C}-0.5)$ 来求和输出。即当 $B_{3C}=1$ 时实际值为 1，当 $B_{3C}=0$ 时实际值为-1，可以实现两个极性的错误都可以纠正。</p>
<p>‍</p>
<h3 id="10-bit-100-MS-s-SAR-ADC-with-binary-权重补偿"><a href="#10-bit-100-MS-s-SAR-ADC-with-binary-权重补偿" class="headerlink" title="10-bit 100-MS/s SAR ADC with binary 权重补偿"></a>10-bit 100-MS/s SAR ADC with binary 权重补偿</h3><p>S/H 电路 +CDAC 阵列 + 比较器结构如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/image-20250515154927-6xdejb5.png" alt="image" title="S/H电路+CDAC阵列+比较器结构图示">​</p>
<ul>
<li>Q：它为什么每 3 个 bit 加一个补偿矫正 bit 呢？</li>
</ul>
<p>A：从 Proposed Binary Search with Error Compensation 的图中来看，每 3 个 bit 一个补偿矫正 bit 可以矫正至多 <code>MSB-1</code> ​为的判断错误，即错误结果与实际结果至多相差 2LSB(注：此处的 LSB 并非全部 10bit 的 LSB，而是每一个分组的电容阵列的 LSB)，参考 <a target="_blank" rel="noopener" href="https://bbs.eetop.cn/thread-948805-1-1.html">SAR ADC 输入范围以及二进制冗余方法 - eetop</a>。但是作者也在文中提出 <code>three compensative cycles achieves the shortest conversion time</code>​，同时 3 个补偿电容带来了 <code>至多12.5%的tolerance</code>​。</p>
<p>这种补偿方法也可以移植到 non-binary 的 CDAC 阵列中，但是 binary-scaled 的 CDAC 的 layout 相对更容易 matching。</p>
<p>‍</p>
<h4 id="Digital-Error-Correction-Logic"><a href="#Digital-Error-Correction-Logic" class="headerlink" title="Digital Error Correction Logic"></a>Digital Error Correction Logic</h4><p>该电路的作用是 converts the 13-bit redundant codes to 10-bit binary codes。这 13-bit 冗余位的权重分别为：</p>
<script type="math/tex; mode=display">
512,256,128,128, |  64,32,16,16, | 8,4,2,2,1</script><p>则 output 满足下式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
output &= 512\times B_{1} + 256\times B_{2} + 128 \times B_{3} + 128\times(B_{3c}-0.5) \\
&= 64\times B_{4} + 32\times B_{5} + 16 \times B_{6} + 16\times(B_{6c}-0.5) \\
&= 8\times B_{7} + 4\times B_{8} + 2 \times B_{9} + 2\times(B_{9c}-0.5) 
\end{aligned}</script><p>因此共计 offset 满足下式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
offset &= 128 \times (-0.5) +  16 \times (-0.5) + 2 \times (-0.5)\\
       &= -73
\end{aligned}</script><p>因此数字误差校正逻辑如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/20250515172651.png" alt="image" title="Implementation of digital error correction logic">​</p>
<ul>
<li>Q：如何理解这个 Logic？</li>
</ul>
<p>A：以后三个 bit 为例，定义 $D_{i}=Res_{i}+B_{i}$，因此有：</p>
<p>当 $B_{10}=0$，则 $D_{10}=1$；当 $B_{10}=1$，则 $D_{10}=0$，同时进位 1，故 $D_{10}=\overline{B_{10}}$；</p>
<p> 当 $B_{9c}=0$ 时，$Res_{9}=1+0=1$；当 $B_{9c}=1$ 时，$Res_{9}=1+1$ 进位，因此 $Res_{9}=\overline{B_{9c}}$；</p>
<p>当 $B_{9c}=0$ 时，$Res_{8}=1+0$​；当 $B_{9c}=1$ 时，$Res_{8}=1+1$ 进位，因此 $Res_{8}=\overline{B_{9c}}$；</p>
<p> 当 $B_{9c}=0$ 时，$Res_{7}=0+0$；当 $B_{9c}=1$ 时，$Res_{8}=0+1$ 进位，因此 $Res_{8}=B_{9c}$；</p>
<p>剩下的 bit 也同理，将上述逻辑表达式转化成电路图(<code>数字电路</code>​)后如下图所示：</p>
<p>因此数字误差校正电路如下图所示：包含 5 个反相器 +9 个全加器</p>
<p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/image-20250515165204-wujfxrc.png" alt="image" title="Implementation of digital error correction logic">​</p>
<p>FA：Full adder；HA：Half adder；MUX：Multiplexer；</p>
<p>‍</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>本 chapter 提出的 binary-scaled error compensation method 主要是为了解决高速 ADC 中 <code>DAC的settling issue问题</code>​。该电容补偿方法对 non-binary search 同样适用。</p>
<p>‍</p>
<p>‍</p>
<h2 id="Splitting-Monotonic-Capacitor-Switching-Procedure"><a href="#Splitting-Monotonic-Capacitor-Switching-Procedure" class="headerlink" title="Splitting Monotonic Capacitor Switching Procedure"></a>Splitting Monotonic Capacitor Switching Procedure</h2><p>Chapter2 提出的单调开关切换策略相较于传统切换策略实现了更高能效同时减少了一半的电容数量。但是输入共模电压的变化带来的比较器的 offset 降低了 ADC 的 performance，因此本 chapter 提出一种 <code>splitting monotonic switching procedure</code> ​来 maintain $V_{CM}$ during bit cycling。同时在 DAC 网络中采用 <code>预测电路</code> ​以减少不必要的开关，这个预测电路由两个 coarse comparators 和 sub-ADC 组成。该 method 进一步节约了 comparator、CDAC 的能耗，同时提高了运行速度及 SAR ADC 的线性度。</p>
<p>下方为单调开关和分离单调开关的结构、切换策略：</p>
<p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/20250516140020.png" alt="image" title="Switching examples: (a) Monotonic switching method. (b) Splitting monotonic switching method."></p>
<p>在第 0 次，由于是采样因此有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
V_{p}(0) &= V_{ip}\\
V_{n}(0) &= V_{in}
\end{aligned}</script><p>因此比较器各端口电荷量满足下式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
Q_{p}(0) &= 4C\cdot (V_{ip}-V_{ref}) + 4C\cdot (V_{ip}-0)\\
Q_{n}(0) &= 4C\cdot (V_{in}-V_{ref}) + 4C\cdot (V_{in}-0)
\end{aligned}</script><p>断开 $V_{ip}$​ 连接后，进行第一次比较，如果 $V_{ip}&gt;V_{in}$ ，则向下切换，切换后各端口电荷量满足下式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
Q_{p}(1) &= (C+C)\cdot (V_{p}(1)-V_{ref}) + 2C\cdot (V_{p}(1)-0) + 4C\cdot (V_{p}(1)-0)\\
Q_{n}(1) &= (C+C)\cdot (V_{n}(1)-0) + 2C\cdot (V_{p}(1)-V_{ref}) + 4C\cdot (V_{n}(1)-V_{ref})
\end{aligned}</script><p>根据电荷量守恒即 $Q_{p}(0)=Q_{p}(1)$​， $Q_{n}(0)=Q_{n}(1)$ 得到下式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
V_{p}(1) &= V_{ip} - \frac{1}{4} V_{ref} \\
V_{n}(1) &= V_{in} + \frac{1}{4} V_{ref}
\end{aligned}</script><p>进而实现对 $V_{ip} - V_{in} &gt;? \frac{1}{2}V_{ref}$​ 的判断。</p>
<hr>
<p>同时对于 monotonic switching procedure，其输入共模电平单调下降，以第三次切换后为例，其比较器各输入端口电压满足下式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
V_{p}(3) &= V_{cm} - V_{ip} + \frac{1}{8} V_{ref} \\
V_{n}(3) &= V_{cm} - V_{in} + \frac{7}{8} V_{ref} \\
V_{cm}(now) &= \frac{1}{2}(V_{p}(3)+V_{n}(3)) = V_{cm} + \frac{1}{2}V_{ref}
\end{aligned}</script><p>​<code>注：此处我怎么算出来共模电平持续增加了，我就请问了？</code>​</p>
<p>但对于 splitting monotonic switching procedure 来说，其共模电平会逐渐趋近于 $V_{cm}$，两种切换策略对比图如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/20250516165403.png" alt="image" title="(a) Waveform of monotonic switching procedure. (b) Waveform of splitting monotonic switching procedure">​</p>
<p>‍</p>
<p>‍</p>
<h2 id="Predictive-Capacitor-Switching-Procedure"><a href="#Predictive-Capacitor-Switching-Procedure" class="headerlink" title="Predictive Capacitor Switching Procedure"></a>Predictive Capacitor Switching Procedure</h2><p>传统的 SAR ADC 是 binary-search algorithm，特别地当外加大电压的同时伴随着 small difference，这会带来不必要的能量消耗。下面是刘纯成博士的 idea：</p>
<p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/20250516170003.png" alt="image" title="The approximations of conventional and proposed methods">​</p>
<p>刘纯成博士的想法是：保持 bit cycling 操作直至差值 &lt;$\frac{1}{2}LSB$，进而再去 add or subtract 电压。</p>
<p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/20250516175527.png" alt="image" title="The architecture proposed SAR ADC">​</p>
<p>综合考虑到效率和能效，因此 CCLiu 选择前 4bit MSB 用 Splitting Monotonic Capacitor Switching Procedure，后面 6 bit 用 Monotonic Capacitor Switching Procedure。</p>
<p>此时 coarse comparator 的判断阈值 $V_{r}$ 的选择即参考它的精度即可，考虑到 $C_{5}=16C_{unit}$，因此取 $V_{r}=\frac{1}{2}Weight_{C_{5}} = 8LSB$ 即可。</p>
<hr>
<p>​<code>idea总结</code>​：在由 Splitting Monotonic Capacitor Switching 的电容决定的精度下，设定该切换策略所对应的 CDAC 的 $\frac{1}{4}LSB_{equal}$ 为电容开关开始切换的临界阈值，在输入信号差值小于 $\frac{1}{4}LSB_{equal}$ 后再实行开关的切换，实现比较速度的提升和能效的提高。</p>
<hr>
<p>特别地在 10-bit 的精度下，比较器 dynamic offset problem 的影响几乎可以忽略。下面我们来讨论一下刘纯成博士在这个 ADC 中提出的 digital error correction logic(仅包含 4 个全加器)：</p>
<p>注意由于我们取的临界阈值电压是 $\frac{1}{4}LSB_{equal}$，因此我们需要同时利用两个 coarse comparator 的比较结果；或者说 $\overline{B_{in}}$ 是 $V_{in} ?&lt; V_{r}$ 的判断结果，$B_{ip}$ 是 $V_{ip} ?&gt; V_{r}$ 的判断结果，因此二者加起来就是 $\overline{B_{in}} + B_{ip} =$</p>
<p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/20250517155504.png" alt="image" title="Digital error correction logic">​</p>
<ul>
<li>以 $D_{1}$ 为例：$\overline{B_{1n}} = 1 \Rightarrow V_{in} <V_{r}$ 并且 $B_{1p} = 1 \Rightarrow V_{ip} >V_{r}$，因此当且仅当 $\overline{B_{1n}} = B_{1p}=1$ 时，有 $D_{1}=1$；</li>
<li>$D_{2}$：</li>
</ul>
<p>‍</p>
<hr>
<p>一个 bit 一个 bit 的分析：</p>
<p><img src="https://raw.githubusercontent.com/Love-learning-Li/picture_save/master/20250520113519.png" alt="image" title="coarse comparator及DAC工作分析">​</p>
<ul>
<li>采样 + 第一次比较：</li>
</ul>
<p>coarse comparator 各输入端口电荷量满足下式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
Q_{p}(0) &= (C_{1b} + C_{2b} + ... +C_{10}) \cdot (V_{ip}-V_{ref}) + (C_{1a} + C_{2a} + ... + C_{4a})\cdot (V_{ip}-0)\\
Q_{n}(0) &= (C_{1b} + C_{2b} + ... +C_{10}) \cdot (V_{in}-V_{ref}) + (C_{1a} + C_{2a} + ... + C_{4a})\cdot (V_{in}-0)
\end{aligned}</script><p>各输入端口电压满足下式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
V_{p}(0) &= V_{ip} \\
V_{n}(0) &= V_{in} 
\end{aligned}</script><p>此时 $V_{r}$ 选定为 $\frac{V_{ref}}{4}$，即判断</p>
<script type="math/tex; mode=display">
\begin{aligned}
B_{1p} &= (V_{ip} > \frac{V_{ref}}{2} )? & 1: 0 \\
\overline{B_{1n}} &= (- V_{in} > - \frac{V_{ref}}{2} )? & 1: 0 
\end{aligned}</script><p>如果有 $V_{ip} &gt; \frac{V_{ref}}{2}$ 且 $V_{in} &lt; \frac{V_{ref}}{2}$，则输出 code 有 $D_{1}=1$；该条件等价于 $B_{1p}=1$ 同时 $\overline{B_{1n}}=1$。</p>
<p>‍</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://love-learning-li.github.io"></a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://love-learning-li.github.io/2025/07/02/CCLiu_paper_reading/">http://love-learning-li.github.io/2025/07/02/CCLiu_paper_reading/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://love-learning-li.github.io" target="_blank">LiMingXiang's Record</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SAR-ADC/">SAR ADC</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/06/18/2025_Spring_final_exam_reveiew/" title="四川大学微电子2022级大三下期末考试植树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">四川大学微电子2022级大三下期末考试植树</div></div><div class="info-2"><div class="info-item-1">IC设计基础1.五管OTA小信号电路+增益求解2.绘制二级运放中宽长比为100:1的输入对管的版图，同时标清楚每个layer的含义​ 3.通过CMOS工艺图和寄生等效放大电路图简述闩锁效应的成因，以及如何减小闩锁效应的方法​ 4.对如下对称OTA电路根据功能划分模块 5.画出如下版图对应的如箭头方向的完整剖面图，并解释为什么多晶硅可以在黑框处跨越N阱​ ‍ 集成电路原理(数集)一、名词解释45分/5分1. 等比例缩小定律是什么，请描述你对其的理解不知道是不是scale down的意思，在保障逻辑功能无误的情况下，先进工艺可以实现更好的能效比和性能。 2. 集成电路与电子线路的区别3. PN结隔离介质中n+掩埋层的作用4. 什么是平面工艺5. 请用CMOS实现与非门，画出电路及版图6. 什么是有比反相器与无比反相器7. 对于与非门，若想实现最高噪声容限，则如何设计nmos、pmos的宽长比考虑n个cmos串联的等效 Kn′ 与单个pmos的 Kp 相等即可。 8. 触发器、寄存器、锁存器的区别9. 请给出若干ADC的性能参数及定义‍ 简答题(最后一个5分，其他8分，共55分)1....</div></div></div></a><a class="pagination-related" href="/2025/08/10/mass_surface_interactive/" title="切比雪夫滤波器阶数计算器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">切比雪夫滤波器阶数计算器</div></div><div class="info-2"><div class="info-item-1">                                 window.PlotlyConfig = {MathJaxConfig: 'local'};         /** * plotly.js v2.32.0 * Copyright 2012-2024, Plotly, Inc. * All rights reserved. * Licensed under the MIT license */ /*! For license information please see plotly.min.js.LICENSE.txt */ !function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.Plotly=e():t.Plotly=e()}(self,(function(){return...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/05/22/Comparator_offset_calculate/" title="比较器offset论文研读"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-22</div><div class="info-item-2">比较器offset论文研读</div></div><div class="info-2"><div class="info-item-1">比较器offset论文研读笔者最近在做比较器的相关电路，需要仿真offset，如果 $V_{FS}=1V$ ，并且是10Bits的ADC的话，则要求offset满足 $V_{OS}&lt;\frac{1}{2}LSB=0.48mV$ 。因此仿真计算比较器的offset有重大意义。 遗憾的是笔者在某宝买的虚拟机没有mis模型，跑不了蒙卡，因此笔者也就萌生出了手算offset的想法，故也就有了本文。 offset定义offset定义：当比较器输出达到 $\frac{V_{DD}}{2}$ 时，输入端 $V_{in}$ 和 $V_{ip}$ 的差值。 首先offset由系统失配和随机失配带来。系统失配指的是电路本身设计所带来的，如下图所示： 系统失配 在图1的二级运放电路图中我们需要保证M3、M4、M6的 $V_{GS}$ 一致，即若实际直流工作点存在偏差的话则会贡献有一部分offset，本文重点分析random...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name"></div><div class="author-info-description">Analog integrated circuit</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CCLiu-%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB"><span class="toc-number">1.</span> <span class="toc-text">CCLiu 论文研读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Non-binary"><span class="toc-number">1.0.1.</span> <span class="toc-text">Non-binary</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Non-binary-search-%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">Non-binary search 详细分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Time-interleaving"><span class="toc-number">1.0.2.</span> <span class="toc-text">Time-interleaving</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-11-20-43-%E6%9A%82%E6%97%B6%E7%9C%8B%E4%B8%8D%E6%87%82%EF%BC%8C%E6%9A%82%E4%B8%94%E5%85%88%E6%90%81%E7%BD%AE"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">5.11 20:43 暂时看不懂，暂且先搁置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Asynchronous"><span class="toc-number">1.0.3.</span> <span class="toc-text">Asynchronous</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reduce-the-switching-energy-in-CDAC"><span class="toc-number">1.0.4.</span> <span class="toc-text">Reduce the switching energy in CDAC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chapter2-%E5%BC%80%E5%85%B3%E7%9A%84%E5%8D%95%E8%B0%83%E5%88%87%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">1.0.5.</span> <span class="toc-text">Chapter2 开关的单调切换策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Conventional-CDAC"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">Conventional CDAC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Proposed-CDAC"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">Proposed CDAC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bootstrapped-switch-design"><span class="toc-number">1.0.6.</span> <span class="toc-text">Bootstrapped switch design</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Comparator-design"><span class="toc-number">1.0.7.</span> <span class="toc-text">Comparator design</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SAR-ADC-control-logic"><span class="toc-number">1.0.8.</span> <span class="toc-text">SAR ADC control logic</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#diagram-%E5%88%86%E6%9E%90"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">diagram 分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Capacitor-Array"><span class="toc-number">1.0.9.</span> <span class="toc-text">Capacitor Array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-bit-50MS-s-SAR-ADC-design"><span class="toc-number">1.0.10.</span> <span class="toc-text">10-bit 50MS&#x2F;s SAR ADC design</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#S-H-circuit"><span class="toc-number">1.0.10.1.</span> <span class="toc-text">S&#x2F;H circuit</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dynamic-Comparator"><span class="toc-number">1.0.11.</span> <span class="toc-text">Dynamic Comparator</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%8F%E5%B0%8F-offset-%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.0.11.0.1.</span> <span class="toc-text">减小 offset 的方法：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-bit-220-MS-s-Time-Interleaving-SAR-ADC"><span class="toc-number">1.0.12.</span> <span class="toc-text">6-bit 220-MS&#x2F;s Time-Interleaving SAR ADC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Comparator-design-1"><span class="toc-number">1.0.12.1.</span> <span class="toc-text">Comparator design</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Q-%E4%B8%8D%E5%90%8C%E4%BA%8E%E4%B8%8A%E4%B8%80%E4%B8%AA-ADC-%E7%9A%84-comparator-%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-number">1.0.12.1.1.</span> <span class="toc-text">Q:不同于上一个 ADC 的 comparator 的原因？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SAR-Logic-Design"><span class="toc-number">1.0.12.2.</span> <span class="toc-text">SAR Logic Design</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%80%9F-SAR-ADC-%E7%9A%84-Binary-Scaled-Error-Compensation"><span class="toc-number">1.1.</span> <span class="toc-text">高速 SAR ADC 的 Binary-Scaled Error Compensation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84-Binary-Search%EF%BC%9A"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">传统的 Binary Search：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Non-binary-Search"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">Non-binary Search</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Proposed-Binary-Search-with-Error-Compensation"><span class="toc-number">1.1.0.3.</span> <span class="toc-text">Proposed Binary Search with Error Compensation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-bit-100-MS-s-SAR-ADC-with-binary-%E6%9D%83%E9%87%8D%E8%A1%A5%E5%81%BF"><span class="toc-number">1.1.1.</span> <span class="toc-text">10-bit 100-MS&#x2F;s SAR ADC with binary 权重补偿</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Digital-Error-Correction-Logic"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">Digital Error Correction Logic</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Summary"><span class="toc-number">1.1.2.</span> <span class="toc-text">Summary</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Splitting-Monotonic-Capacitor-Switching-Procedure"><span class="toc-number">1.2.</span> <span class="toc-text">Splitting Monotonic Capacitor Switching Procedure</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Predictive-Capacitor-Switching-Procedure"><span class="toc-number">1.3.</span> <span class="toc-text">Predictive Capacitor Switching Procedure</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/10/mass_surface_interactive/" title="切比雪夫滤波器阶数计算器">切比雪夫滤波器阶数计算器</a><time datetime="2025-08-10T09:15:20.981Z" title="发表于 2025-08-10 17:15:20">2025-08-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/02/CCLiu_paper_reading/" title="CCLiu 论文研读">CCLiu 论文研读</a><time datetime="2025-07-02T07:31:41.985Z" title="发表于 2025-07-02 15:31:41">2025-07-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/18/2025_Spring_final_exam_reveiew/" title="四川大学微电子2022级大三下期末考试植树">四川大学微电子2022级大三下期末考试植树</a><time datetime="2025-06-18T13:17:45.531Z" title="发表于 2025-06-18 21:17:45">2025-06-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/03/2_stage_amp_parameter_desing_notes/" title="两级运放调参总结">两级运放调参总结</a><time datetime="2025-06-03T14:47:56.969Z" title="发表于 2025-06-03 22:47:56">2025-06-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/22/MOS(100)_BJT(111)/" title="为什么MOS管常用(100)晶向的晶圆，BJT常用(111)晶向的晶圆？">为什么MOS管常用(100)晶向的晶圆，BJT常用(111)晶向的晶圆？</a><time datetime="2025-05-22T03:31:44.228Z" title="发表于 2025-05-22 11:31:44">2025-05-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By null</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>